module Spontaneous::Field
  class Image
    class Processor
      include Utilities

      class ImageDelegator < SimpleDelegator

        def initialize(image)
          super(image)
        end

        alias_method :image, :__getobj__

        def format(*args, &block)
          image.format(*args, &block)
        end

        def fit(width, height)
          image.combine_options do |c|
            c.add_command(:geometry, "#{width}x#{height}>")
          end
        end

        def crop(width, height)
          image.combine_options do |c|
            dimensions = "#{width}x#{height}"
            c.add_command(:geometry, "#{dimensions}^")
            c.add_command(:gravity, "center")
            c.add_command(:crop, "#{dimensions}+0+0!")
          end
        end

        def width(width)
          image.combine_options do |c|
            c.add_command(:geometry, "#{width}x>")
          end
        end

        def height(height)
          image.combine_options do |c|
            c.add_command(:geometry, "x#{height}>")
          end
        end

        def greyscale
          image.combine_options do |c|
            c.add_command(:type, "Grayscale")
          end
        end

        def composite(other_image_path, output_extension = "jpg", &block)
          ::File.open(other_image_path) do |other_image|
            new_image = image.composite(other_image, output_extension, &block)
            image.path = new_image.path
          end
        end

        def smush_it!
          ::Spontaneous::Utils::SmushIt.smush!(image.path, current_image_format)
        end

        def optimize!
          Optimizer.run(image.path) if current_image_format == "jpg"
        end

        def border_radius(radius, bg_color = nil)
          @image.format('png') if bg_color.nil? or bg_color == 'transparent'
          puts @image.path
          c = MiniMagick::CommandBuilder.new('convert')
          c << @image.path
          c.add_command(:format, "roundrectangle 0,0 %[fx:w-1],%[fx:h-1], 10,10")
          c.add_command(:write, "info:tmp.mvg")
          c << @image.path

          puts c.command
          # @image.run(c)
          sub = Subexec.run(c.command, :timeout => MiniMagick.timeout)

          c = MiniMagick::CommandBuilder.new('convert')

          c << @image.path
          # c.add_command(:write, "info:tmp.mvg")
          c.add_command(:matte)
          c.add_command(:bordercolor, "none")
          c.add_command(:border, "0")
          c.push('\\(')
          c.push("+clone")
          c.add_command(:alpha, 'transparent')
          c.add_command(:background, 'white')
          c.add_command(:fill, 'white')
          c.add_command(:stroke, 'none')
          c.add_command(:strokewidth, '0')
          c.add_command(:draw, "@tmp.mvg")
          c.push('\\)')
          c.add_command(:compose, 'DstIn')
          c.add_command(:composite)
          c << @image.path
          puts c.command
          @image.run(c)

        end


        def __run__(process)
          instance_eval(&process)
        end

        def method_missing(method, *args, &block)
          params = args.map(&:to_s)
          if image.respond_to?(method)
            image.__send__(method, *params, &block)
          else
            image.method_missing(method, *params, &block)
          end
        end

        def current_image_format
          image[:format].downcase.gsub(/^jpeg$/, "jpg")
        end
      end

      MAX_DIM = 2 ** ([42].pack('i').size * 8) - 1 unless defined?(MAX_DIM)

      attr_reader :path

      def initialize(media_file)
        @media_file = media_file
        @path = media_file.source
      end

      def src
        @media_file.url
      end

      def filesize
        ::File.size(path)
      end

      def width
        dimensions[0]
      end

      def height
        dimensions[1]
      end

      def dimensions
        @dimensions ||= Spontaneous::ImageSize.read(path)
      end

      def apply(process, name, tempfile)
        image = ::MiniMagick::Image.open(path)
        processor = Processor::ImageDelegator.new(image)
        processor.__run__(process)
        file = @media_file.rename(filename_for_size(name, image))
        # copy the image into the tempfile provided by the parent #generate call
        # this stops us from using a tempfile that is out of our control and can
        # be closed before we're done
        FileUtils.cp(image.path, tempfile.path)
        file.copy(tempfile)

        Processor.new(file)
      end

      def filename_for_size(name, image)
        original_filename = @media_file.filename
        parts = original_filename.split('.')

        # use the image format for the extension because tempfiles generated by
        # mini_magick don't have extensions
        # I hate the "jpeg" extension though
        ext = image[:format].downcase.gsub(/^jpeg$/, "jpg")
        base = parts[0..-2].join('.')
        filename = [base, name, ext].join('.')
        filename
      end

      def serialize
        {
          :src => src,
          :width => width,
          :height => height,
          :filesize => filesize,
          :path => @media_file.path
        }
      end

      def inspect
        %(#<Spontaneous::Field::Image::Processor:#{self.object_id} @media_file=#{@media_file.inspect}>)
      end
    end
  end
end
